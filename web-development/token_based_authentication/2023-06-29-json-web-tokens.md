---
layout: post
title:
description: ''
date: '2023-06-29'
categories: token_based_authentication
note:
mathjax:
mermaidJS: true
p5JS:
chartJS:
threeJS:
publish: true
---

## Introduction

This article explains the concept of JSON Web Tokens (JWT) and demonstrates their implementation using Ruby on Rails and Vue.js. It covers the process of creating and verifying JWTs, highlighting their role in secure authentication and authorization in distributed systems.

## Why?

JWT (JSON Web Token) are used as a secure and compact means of transmitting and verifying claims or information between parties, enabling stateless authentication and authorization in distributed systems.

## How?

### Concept

<div class="mermaid">
  graph LR
    user(User) -- email, password --> sign_up_or_login_page[Sign Up or Login Page]
    sign_up_or_login_page[Landing Page] -- email, password --> jwt_service_create[JWT Creation Service]
    jwt_service_create[JWT Creation Service] -- JWT --> user(User)
    user(User) -- JWT --> secured_website(Secured Website)
    secured_website(Secured Website) -- JWT --> jwt_service_validate[JWT Validation Service]
    jwt_service_validate[JWT Validation Service] -- validate? --> secured_website(Secured Website)
    secured_website(Secured Website) -- validate? == yes --> show_page((Show Page))
    secured_website(Secured Website) -- validate? == no --> no_page((No Page))
</div>

In the context of the provided graph, JWT serves as a **secure token** that facilitates the **reliable exchange** of **user information** between two parties involved.
* User information: We called it **claims**; for example, the user's name, ID, roles, or any other relevant data.
* Secure token
  * Encoding: The JSON object with user information is encoded with **Base64Url**, resulting in a compact string that allows for easy transmission of the JWT across different systems without data loss.
  * Signature: To ensure integrity and **prevent tampering**, a signature is generated by calculating it over the encoded JWT using a shared secret key, and then appending it to the JWT separated by a period.
* Reliable Exchange: The JWT is commonly transmitted as a **Bearer Token** in the Authorization header of an HTTP request, prefixed with the word "Bearer" followed by a space, before the actual JWT.

### Pseudocode of JWT in Ruby

#### Use case

```ruby
secret_key = 'your-secret-key' # For signature, so that we can prevent any tampering from frontend
jwt_service = JWTService.new(secret_key)

payload = { user_id: 123, role: 'admin' } # Claims

# Encode and sign the JWT token
token = jwt_service.encode_jwt(payload) # Going to return this token to frontend

# Decode and verify the JWT token received from frontend
begin
  decoded_payload = jwt_service.decode_jwt(token)
  puts "Decoded Payload: #{decoded_payload}"
rescue StandardError => e
  puts "Invalid token: #{e.message}"
end
```

#### Service

```ruby
require 'base64'
require 'openssl'
require 'json'

class JWTService
  def initialize(secret_key)
    @secret_key = secret_key
  end

  def encode_jwt(payload)
    encoded_payload = base64_url_encode(payload.to_json)
    signature = sign_token(encoded_payload) # Depends on payload and secret key

    data + '.' + signature
  end

  def decode_jwt(token)
    parts = token.split('.')
    encoded_payload = parts[1]
    signature = parts[2]

    payload = JSON.parse(base64_url_decode(encoded_payload))

    data = parts[0] + '.' + encoded_payload
    calculated_signature = sign_token(data)

    if signature == calculated_signature
      payload
    else
      raise 'Invalid token: Signature mismatch'
    end
  end

  private

  def base64_url_encode(data)
    Base64.urlsafe_encode64(data).gsub('=', '')
  end

  def base64_url_decode(encoded_data)
    padding_length = 4 - (encoded_data.length % 4)
    encoded_data += '=' * padding_length

    Base64.urlsafe_decode64(encoded_data)
  end

  def sign_token(data)
    hmac = OpenSSL::HMAC.digest(OpenSSL::Digest.new('sha256'), @secret_key, data)
    signature = base64_url_encode(hmac)
    signature
  end
end
```

## What

### Rails + Vue

In rails, we usually use the gem, `jwt` to do the trick.

#### Rails

##### Create JWT

* Concept: After user input username and password, frontend will post it to backend and if the password is matched, the backend create JWT and return to the frontend.
* Code example
  ```ruby
  class SessionsController < ApplicationController
    def create
      user = User.find_by(username: params[:username])
  
      if user && user.authenticate(params[:password])
        # Generate a JWT token
        token = JWT.encode(
          {
            user_id: user.id,
            # more claims
          },
          Rails.application.secrets.secret_key_base, # For signature
          'HS256'
        )
  
        render json: { token: token }
      else
        render json: { error: 'Invalid credentials' }, status: :unauthorized
      end
    end
  end
  ```

#### Verify JWT

* Concept: Define the method to authorize the JWT in base controller and if we need to protect a method, we write the before_action for that method and the `authorize_request` method will do the JWT decode.
* Code Example
  * Protected Controller
    ```ruby
    class ProtectedController < ApplicationController
      before_action :authorize_request
    
      def index
        render json: { message: 'Protected endpoint accessed successfully' }
      end
    end
    ```
  * The code to verify JWT in `ApplicationController`
    ```ruby
    class ApplicationController < ActionController::API
      private
    
      def authorize_request
        authorization_header = request.headers['Authorization']
        token = authorization_header&.split(' ')&.last
    
        begin
          decoded_token = JWT.decode(
            token,
            Rails.application.secrets.secret_key_base,
            true,
            algorithm: 'HS256'
          )
          user_id = decoded_token[0]['user_id']
          @current_user = User.find_by(id: user_id)
        rescue JWT::DecodeError, ActiveRecord::RecordNotFound
          render json: { error: 'Unauthorized' }, status: :unauthorized
        end
      end
    end
    ```

#### Vue

##### Get JWT when login

* Purpose: After the user input the password and username, we store the JWT from backend in local storage.
* Code example
  ```javascript
  <template>
    <form @submit.prevent="handleLogin">
      <input type="text" v-model="username" placeholder="Username" />
      <input type="password" v-model="password" placeholder="Password" />
      <button type="submit">Login</button>
    </form>
  </template>
  
  <script>
  import axios from 'axios';
  
  export default {
    data() {
      return {
        username: '',
        password: '',
      };
    },
    methods: {
      async handleLogin() {
        try {
          const response = await axios.post('/login', {
            username: this.username,
            password: this.password,
          });
  
          const token = response.data.token;
          // Store the token in "local storage" or session storage for later use
  
          // Redirect the user to a protected route or perform other actions
        } catch (error) {
          console.error(error);
          // Handle login error
        }
      },
    },
  };
  </script>
  ```

#### Use JWT

* Purpose: We create a `api.js` as a base to setup JWT for all other protected component. With JWT in header, the controller for this protected component can get JWT and do verification.
* Code example
  * base component, `api.js`
    ```javascript
    import axios from 'axios';
    
    const api = axios.create({
      baseURL: 'https://your-api-url.com',
    });
    
    // Add an interceptor to include the JWT token in the request headers
    api.interceptors.request.use((config) => {
      const token = localStorage.getItem('token');
      if (token) {
        config.headers.common['Authorization'] = `Bearer ${token}`;
      }
      return config;
    });
    
    export default api;
    ```
  * Protected Component
    ```javascript
    <template>
      <div>
        <h2>Protected Component</h2>
        <button @click="accessProtectedEndpoint">Access Protected Endpoint</button>
        <div v-if="message">{{ message }}</div>
        <div v-if="error">{{ error }}</div>
      </div>
    </template>
    
    <script>
    import api from './api';
    
    export default {
      data() {
        return {
          message: '',
          error: '',
        };
      },
      methods: {
        async accessProtectedEndpoint() {
          try {
            const response = await api.get('/protected');
    
            this.message = response.data.message;
            this.error = '';
          } catch (error) {
            this.message = '';
            this.error = error.response ? error.response.data.error : error.message;
          }
        },
      },
    };
    </script>
    ```

## Reference

Myself + ChatGPT
